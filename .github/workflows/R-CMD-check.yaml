name: R-CMD-check

on:
  push:
    branches: [unit-test]
  pull_request:
    branches: [unit-test]

jobs:
  R-CMD-check:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write

    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
      R_KEEP_PKG_SOURCE: true

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up R
      uses: r-lib/actions/setup-r@v2
      with:
        r-version: release

    - name: Cache R packages
      uses: actions/cache@v4
      with:
        path: ${{ env.R_LIBS_USER }}
        key: ${{ runner.os }}-r-${{ hashFiles('**/*.R') }}-release
        restore-keys: |
          ${{ runner.os }}-r-release
          ${{ runner.os }}-r-

    - name: Install dependencies
      uses: r-lib/actions/setup-r-dependencies@v2
      with:
        extra-packages: |
          any::devtools
          any::testthat
          any::rcmdcheck
          any::stringr
          any::httr
          any::jsonlite
          
    - name: Run tests and write results
      run: |
        Rscript -e '
        library(testthat)
        library(humind)

        # Function to write lines and append
        write_append <- function(text, file) {
          cat(paste0(text, "\n"), file = file, append = TRUE)
        }

        # Diagnostic information
        write_append("Diagnostic Information:", "test_results.txt")
        write_append("------------------------", "test_results.txt")
        write_append(paste("Current working directory:", getwd()), "test_results.txt")
        write_append("Files in tests/testthat:", "test_results.txt")
        write_append(paste(list.files("tests/testthat"), collapse = "\n"), "test_results.txt")
        capture.output(print(sessionInfo()), file = "test_results.txt", append = TRUE)

        # Run tests and capture all output
        write_append("\nTest Output:", "test_results.txt")
        write_append("------------", "test_results.txt")
        
        test_output <- capture.output({
          tryCatch({
            test_results <- testthat::test_dir("tests/testthat", reporter = testthat::ProgressReporter$new(max_failures = 10))
            print(test_results)
          }, error = function(e) {
            cat("Error running tests:", conditionMessage(e), "\n")
          }, warning = function(w) {
            cat("Warning during tests:", conditionMessage(w), "\n")
          })
        })
        
        write_append(paste(test_output, collapse = "\n"), "test_results.txt")

        # Print content of test_results.txt for debugging
        cat("Contents of test_results.txt:\n")
        cat(readLines("test_results.txt"), sep = "\n")
        '
      continue-on-error: true

    - name: Create GitHub issues
      if: failure()
      run: |
        Rscript -e '
        library(stringr)
        library(httr)
        library(jsonlite)

        # Function to create a GitHub issue
        create_issue <- function(title, body) {
          url <- "https://api.github.com/repos/impact-initiatives-hppu/humind/issues"
          headers <- c(
            "Authorization" = paste("token", Sys.getenv("GITHUB_TOKEN")),
            "Accept" = "application/vnd.github.v3+json"
          )
          payload <- list(title = title, body = body)
          response <- httr::POST(url, httr::add_headers(.headers = headers), body = payload, encode = "json")
          httr::stop_for_status(response)
        }

        # Read test results
        test_results <- readLines("test_results.txt")

        # Find the start of test output
        test_start <- which(test_results == "Test Output:")
        if (length(test_start) > 0) {
          test_output <- test_results[test_start:length(test_results)]
          
          # Process test failures and create issues
          current_context <- NULL
          current_test <- NULL
          failure_body <- character()

          for (line in test_output) {
            if (startsWith(line, "Context: ")) {
              if (!is.null(current_context) && !is.null(current_test) && length(failure_body) > 0) {
                create_issue(
                  sprintf("[Test Failure] %s: %s", current_context, current_test),
                  paste(c(sprintf("Context: %s", current_context), 
                          sprintf("Test: %s", current_test), 
                          failure_body), 
                        collapse = "\n")
                )
                failure_body <- character()
              }
              current_context <- sub("Context: ", "", line)
              current_test <- NULL
            } else if (startsWith(line, "  Test: ")) {
              if (!is.null(current_test) && length(failure_body) > 0) {
                create_issue(
                  sprintf("[Test Failure] %s: %s", current_context, current_test),
                  paste(c(sprintf("Context: %s", current_context), 
                          sprintf("Test: %s", current_test), 
                          failure_body), 
                        collapse = "\n")
                )
                failure_body <- character()
              }
              current_test <- sub("  Test: ", "", line)
            } else if (startsWith(line, "    Failure: ") || startsWith(line, "    Call: ")) {
              failure_body <- c(failure_body, line)
            }
          }

          # Create issue for the last failure if any
          if (!is.null(current_context) && !is.null(current_test) && length(failure_body) > 0) {
            create_issue(
              sprintf("[Test Failure] %s: %s", current_context, current_test),
              paste(c(sprintf("Context: %s", current_context), 
                      sprintf("Test: %s", current_test), 
                      failure_body), 
                    collapse = "\n")
            )
          }
        } else {
          # If no test output found, create a single issue with the entire output
          create_issue(
            "Test Suite Failure",
            paste(test_results, collapse = "\n")
          )
        }
        '